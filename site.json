{"title":"Mobile OnBoarding","githubRepo":"liferay-mobile/mobile-onboarding","googleAnalytics":"","index":{"title":"Home","description":"Liferay Engineering Brazil","content":" Copyright © 2018 Liferay, Inc Powered by WeDeploy™ ","srcFilePath":"src/pages/index.soy","id":"pages","location":"/./","url":"/./","children":{"documentation":{"title":"Documentation","description":"Everything you need to know to get started.","content":" Documentation Start learning how Liferay does all that! Choose a Guide Each one provide step by step coverage for every core feature. ","srcFilePath":"src/pages/documentation/index.soy","id":"documentation","location":"/documentation/","url":"/documentation/","children":{"search":{"title":"Search","description":"Find what you're looking for in the documentation.","hidden":true,"content":" Electric Docs Start learning how Liferay does all that! ","srcFilePath":"src/pages/documentation/search.soy","id":"search","location":"/documentation/search.html","url":"/documentation/search.html"},"frontend-taglib":{"title":"Front-end TAGLIB","description":"Liferay Portal offers a powerful set of taglibs that are fully maintained and integrated. They provide common implementations for UI components and utilities to ensure that your app behaves in a very clean and efficient way.","layout":"guide","icon":"code-file","weight":6,"content":" {$page.description} Using the Liferay UI TAGLIB You can create a lot of components using the \\\\ taglibs. Liferay Portal’s taglibs provide the following benefits to your markup: Consistent Responsive Accessible across your portlets The full markup generated by the tags can be found in the JSPs of the tag’s folder in the Liferay Github Repo. Using Liferay UI TAGLIB A list of the available \\\\ taglibs can be found here. To use the Liferay-UI taglib library you must add the following declaration to your JSP: Each taglib has a list of attributes that can be passed to the tag. Some of these are required and some are optional. See the taglib docs to view the requirements for each tag. The example below uses the \\\\ taglib to create a success alert that the user can close: Here is an example implementation of a \\\\ taglib: Using Liferay UTIL TAGLIB The \\\\ taglib is used to pull in other resources into a portlet or theme, it can be used to dictate which resources need to be inserted at the bottom or top of the HTML source. A list of the available \\\\ tags can be found here. To use the Liferay-Util taglib library you must add the following declaration to your JSP: Each taglib has a list of attributes that can be passed to the tag. Some of these are required and some are optional. See the taglib docs to view the requirements for each tag. The example below uses the \\\\ taglib. This tag makes the content placed between the opening and closing of this tag is moved to the bottom of the body tag. When something is passed using this taglib, the body_bottom.jsp is passed markup and outputs in this JSP. The attribute outputKey is the reference key for this content. More details, access dev.liferay. ","srcFilePath":"src/pages/documentation/frontend-taglib/index.md","id":"frontend-taglib","location":"/documentation/frontend-taglib/","url":"/documentation/frontend-taglib/"},"introduction-liferay":{"title":"Liferay Development","description":"","layout":"guide","icon":"code-file","weight":2,"content":" Intro to Liferay Development Liferay Portal offers developers a complete platform for building web apps, mobile apps, and web services quickly, using features and frameworks designed for rapid development, good performance, and ease of use. The base platform is already there, and it’s built as a robust container for applications that you can put together in far less time than you would from scratch. It also ships with a default set of common applications that can be make use of right away: web experience management, collaboration applications such as forums and wikis, documents and media, blogs, and more. All of these applications are designed to be customized, as is the system itself. Liferay Portal ships with suites of applications to get you started building your site quickly. One of the most often cited best characteristics of Liferay is how versatile it is. It can be used to build websites of all sorts, from very large websites with hundreds of thousands of articles, to smaller, highly dynamic and interactive sites. This includes public sites, internal sites like intranets, or mixed environments like collaboration platforms. Developers often choose Liferay for one of these cases and quickly find that Liferay is a great fit for completely different projects. In short, Liferay was written by developers for developers, to help get the work done faster and more easily. More details, access dev.liferay. ","srcFilePath":"src/pages/documentation/introduction-liferay/index.md","id":"introduction-liferay","location":"/documentation/introduction-liferay/","url":"/documentation/introduction-liferay/"},"mvc-portlet":{"title":"Liferay MVC Portlet","description":"","layout":"guide","icon":"code-file","weight":4,"content":" {$page.description} MVC Portlet Web applications are often developed following the Model View Controller (MVC) pattern. But Liferay has developed a different implementation for the MVC model. The Liferay MVC portlet framework is light, it hides part of the complexity of portlets, and it makes the most common operations easier. In MVC pattern, there are three layers: Model: The model layer holds the application data and logic for manipulating it. View: The view layer contains logic for displaying data. Controller: The middle man in the MVC pattern, the Controller contains logic for passing the data back and forth between the view and the model layers. Liferay’s applications are divided into multiple discrete modules. With Service Builder, the model layer is generated into a service and an api module. That accounts for the model in the MVC pattern. The view and the controller share a module, the web module. In a larger application, Liferay provides MVC command classes to break up your controller functionality: MVCActionCommand: Use -ActionCommand classes to hold each of your portlet actions, which are invoked by action URLs. MVCRenderCommand: Use -RenderCommand classes to hold a render method that dispatches to the appropriate JSP, by responding to render URLs. MVCResourceCommand: Use -ResourceCommand classes to execute resource serving in your MVC portlet, by responding to resource URLs. MVC Action Command Liferay’s MVC framework lets you split your portlet’s action methods into separate classes. This can be very helpful in portlets that have many actions. Each action URL in your portlet’s JSPs then calls the appropriate action class when necessary. First, use the tag to create the action URL in your JSP. For example, the edit blog entry action in Liferay’s Blogs app is defined in the edit_entry.jsp file as follows: When the action URL is triggered, the matching action class processes the action. Implement the action by creating a class that implements the MVCActionCommand interface. To avoid writing oodles of boilerplate code, your *MVCActionCommand class should extend the BaseMVCActionCommand class instead of implementing MVCActionCommand directly. The BaseMVCActionCommand class already implements MVCActionCommand and provides many useful method implementations. Naming your MVCActionCommand class after the action it performs is a good convention. For example, if your action edits some kind of entry, you could name its class EditEntryMVCActionCommand. Your *MVCActionCommand class must also have a @Component annotation like the following. Set the property javax.portlet.name to your portlet’s internal ID, and the property mvc.command.name to the value of the name property in your JSP’s matching actionURL. To register the component in the OSGi container as using the MVCActionCommand class, you must set the service property to MVCActionCommand.class: @Component( immediate = true, property = { \"javax.portlet.name=yourportletname_YourPortlet\", \"mvc.command.name=/your/jsp/action/url\" }, service = MVCActionCommand.class ) public class YourMVCActionCommand extends BaseMVCActionCommand { // implement your action } For example, this is the @Component annotation for the Blogs app’s EditEntryMVCActionCommand class: @Component( immediate = true, property = { \"javax.portlet.name=\" + BlogsPortletKeys.BLOGS, \"javax.portlet.name=\" + BlogsPortletKeys.BLOGS_ADMIN, \"javax.portlet.name=\" + BlogsPortletKeys.BLOGS_AGGREGATOR, \"mvc.command.name=/blogs/edit_entry\" }, service = MVCActionCommand.class ) public class EditEntryMVCActionCommand extends BaseMVCActionCommand { // the app's edit blog entry action implementation } Note that you can use multiple javax.portlet.name values to indicate the component works with multiple portlets. In your *MVCActionCommand class, process the action by overriding the BaseMVCActionCommand class’s doProcessAction method. This method takes javax.portlet.ActionRequest and javax.portlet.ActionResponse parameters that you can use to process your action. Your MVCActionCommand class should also contain any other code required to implement your action. MVC Render Command MVCRenderCommand is used to respond to portlet render URLs. To use MVC render commands, you need these things: An implementation of the MVCRenderCommand interface. A portlet render URL in your view layer. A Component that publishes the MVCRenderCommand service, with two properties Implementing MVCRenderCommand What is it you want to do when a portlet render URL is invoked? Using the mvcRenderCommandName parameter, direct the request to an MVCRenderCommand implementation. Now override the render method. Some MVCRenderCommand will simply render a particular JSP. Here’s what BlogsViewMVCRenderCommand looks like: @Override public String render( RenderRequest renderRequest, RenderResponse renderResponse) { return \"/blogs/view.jsp\"; } Sometimes you’ll want to add logic to render a certain JSP based on one or more conditions: @Override public String render( RenderRequest renderRequest, RenderResponse renderResponse) throws PortletException { try { ActionUtil.getEntry(renderRequest); } catch (Exception e) { if (e instanceof NoSuchEntryException || e instanceof PrincipalException) { SessionErrors.add(renderRequest, e.getClass()); return \"/hello/error.jsp\"; } else { throw new PortletException(e); } } return \"/hello/edit_entry.jsp\"; } If there’s an error caught following the call to ActionUtil.getEntry in the code above, the error.jsp is rendered. If the call is returned without an exception being caught, edit_entry.jsp is rendered. How does a request get directed to your MVC render command? Using a portlet render URL. Creating a Portlet Render URL You can generate a render URL for your portlet using the \\\\ taglib. To invoke your MVC render command from the render URL, you need to specify the parameter mvcRenderCommandName with the same value as your Component property mvc.command.name. For example, you can create a URL that directs the user to a page with a form for editing an entry like this (in a JSP): Now the request will contain a parameter named mvcRenderCommandName. To find the proper MVC render command, the OSGi runtime needs to have a mvc.command.name property with a matching value. Registering the MVC Render Command In order to respond to a particular render URL, you need an MVCRenderCommand Component that with two properties: javax.portlet.name=\" + HelloWorldPortletKeys.HELLO_WORLD,\" mvc.command.name=/hello/edit_entry Using the above properties as an example, any portlet render URL for the portlet that includes a parameter called mvcRenderCommand with the value /hello/edit_entry will be handled by this MVCRenderCommand. The Component must also publish a MVCRenderCommand.class service to the OSGi runtime. Here’s a basic Component that publishes an MVC render command: @Component( immediate = true, property = { \"javax.portlet.name=\" + HelloWorldPortletKeys.HELLO_WORLD, \"mvc.command.name=/hello/edit_entry\" }, service = MVCRenderCommand.class ) public class EditEntryMVCRenderCommand implements MVCRenderCommand { One command can be used by one portlet, as the example above shows. If you want, one command can be used for multiple portlets by adding more javax.portlet.name entries in the property list. Likewise, multiple commands can invoke the MVC command class by adding more mvc.command.name entries. If you’re really feeling wild, you can specify multiple portlets and multiple command URLs in the same command component, like this: @Component( immediate = true, property = { \"javax.portlet.name=\" + HelloWorldPortletKeys.HELLOMYWORLD, \"javax.portlet.name=\" + HelloWorldPortletKeys.HELLO_WORLD, \"mvc.command.name=/hello/editsuperentry\", \"mvc.command.name=/hello/edit_entry\" }, service = MVCRenderCommand.class ) More details, access dev.liferay. ","srcFilePath":"src/pages/documentation/mvc-portlet/index.md","id":"mvc-portlet","location":"/documentation/mvc-portlet/","url":"/documentation/mvc-portlet/"},"osgi":{"title":"Modularity and OSGI","description":"","layout":"guide","icon":"code-file","weight":3,"content":" {$page.description} Modularity and OSGI Modularity refers to a software/Web application that may be divided into smaller modules. Software modularity indicates that the number of application modules are capable of serving a specified business domain. Some of the modularity benefits for the software are: distinct functionality, dependencies, encapsulation and reusability. Liferay Portal is modular too. It comprises code modules created and tested independently and in parallel. It’s a platform on which modules and modular applications are installed, started, used, stopped, and uninstalled. Liferay Portal’s components use the OSGi modularity standard. Modules are the basic unit of modularity for applications. They act as containers for the application’s features and functionality. These self-contained units are deployed within Liferay’s OSGI Container. In order to deploy a module, it must be packaged in a bundle. An OSGI bundle is nothing but a JAR file with extra meta data. A bundle contains java classes, a manifest file and other resources (JSPs, properties files, text data). So we can say that every OSGI bundle is JAR file, but reverse is not true. That means that if you want to convert a JAR file into bundle it's necessary to add extra metadata into the MANIFEST.MF file. These extra meta data are known as OSGI Headers, key elements which turns a normal JAR file into a Bundle. OSGI Bundle Life Cycle: INSTALLED: The bundle has been installed into the OSGi container, but some required bundle dependencies are missing. A bundle in this state can’t be started. RESOLVED: All Java classes that the bundle needs are available. This state indicates that the bundle is either ready to be started or has stopped. STARTING: The bundle is being started, the BundleActivator.start method has been called but the start method has not yet returned. When the bundle has an activation policy, the bundle will remain in the STARTING state until the bundle is activated according to its activation policy. ACTIVE: The bundle has been successfully activated and is running. Its Bundle Activator start method has been called and returned. STOPPING: The bundle is being stopped. The BundleActivator.stop method has been called but the stop method has not yet returned. UNINSTALLED: The bundle has been uninstalled. It cannot move into another state. More details, access dev.liferay. ","srcFilePath":"src/pages/documentation/osgi/index.md","id":"osgi","location":"/documentation/osgi/","url":"/documentation/osgi/"},"portlet":{"title":"Portlet","description":"","layout":"guide","icon":"code-file","weight":3,"content":" {$page.description} Portlet Web apps in Liferay Portal are called portlets. Like many web apps, portlets process requests and generate responses. In the response, the portlet returns content (e.g. HTML, XHTML) for display in browsers. One key difference is that portlets run in a portion of the web page, it means you only need to worry about the application because any interface component is handled by other components. Another difference is that portlets run only in a portal server, like the one in Liferay Portal. Portlets can therefore use the portal’s existing support for user management, authentication, permissions, page management, and more. This frees you to focus on developing the portlet’s core functionality. In many ways, writing your application as a portlet is easier than writing a standalone application. One page can contain several different portlets, for example: a page in a community site could have a calendar portlet for community events, an announcements portlet for important announcements, and a bookmarks portlet for links of interest to the community. And because the portal controls page layout, you can reposition and resize one or more portlets on a page without altering any portlet code. Doing all this in other types of web apps would require manual re-coding. Since the portlets are components, in other words, they are independent functional objects, it means that will have a lifecycle: Activate: when a component is being started. Active: the component is started and available. Deactivate: the component is being stopped. Portlets handle requests in multiple phases. This makes portlets much more flexible than servlets. Each portlet phase executes different operations: AInit: It is the first phase a potlet goes through when it’s deployed. During this phase, portlets typically initialize any backend resources or perform any one-time activities that they need. ARender: Generates the portlet’s contents based on the portlet’s current state. When this phase runs on one portlet, it also runs on all other portlets on the page. The Render phase runs when any portlets on the page complete the Action or Event phases. AAction: In response to a user action, performs some operation that changes the portlet’s state. The Action phase can also trigger events that are processed by the Event phase. Following the Action phase and optional Event phase, the Render phase then regenerates the portlet’s contents. AEvent: Processes events triggered in the Action phase. Events are used for IPC. Once the portlet processes all events, the portal calls the Render phase on all portlets on the page. AResource-serving: Serves a resource independent from the rest of the lifecycle. This lets a portlet serve dynamic content without running the Render phase on all portlets on a page. The Resource-serving phase handles AJAX requests. ADestroy: This phase is called by the portlet container when the portlet is uninstalled. This phase is designed to allow the portlet to release any resources it needs to and to save its state if necessary. The render phase can be further subdivided into different modes, which gives users an easy way to access a particular page in a portlet. Modes distinguish the portlet’s current function: View mode: The portlet’s standard mode. Use this mode to access the portlet’s main functionality. Edit mode: The portlet’s configuration mode. Use this mode to configure a custom view or behavior. For example, the Edit mode of a weather portlet could let you choose a location to retrieve weather data from. Help mode: A mode that displays the portlet’s help information. Most modern applications use View Mode only. Portlet window states control the amount of space a portlet takes up on a page. Window states mimic window behavior in a traditional desktop environment: Normal: The portlet can be on a page that contains other portlets. This is the default window state. Maximized: The portlet takes up an entire page. Minimized: Only the portlet’s title bar shows. Compared to servlets, portlets also have some other key differences. Since portlets only render a portion of a page, tags like \\\\, \\\\, and \\ aren’t allowed. And because you don’t know the portlet’s page ahead of time, you can’t create portlet URLs directly. Instead, the portlet API gives you methods to create portlet URLs programmatically. Also, because portlets don’t have direct access to the javax.servlet.ServletRequest, they can’t read query parameters directly from a URL. Portlets instead access a javax.portlet.PortletRequest object. The portlet specification only provides a mechanism for a portlet to read its own URL parameters or those declared as public render parameters. Liferay Portal does, however, provide utility methods that can access the ServletRequest and query parameters. Portlets also have a portlet filter available for each phase in the portlet lifecycle. Portlet filters are similar to servlet filters in that they allow request and response modification on the fly. More details, access dev.liferay. ","srcFilePath":"src/pages/documentation/portlet/index.md","id":"portlet","location":"/documentation/portlet/","url":"/documentation/portlet/"},"soy-templates":{"title":"Soy Templates","description":"","layout":"guide","icon":"code-file","weight":7,"content":" Soy templates are a templating system for dynamically generating re-usable HTML and UI elements in both Java and JavaScript. Soy templates are also referred to as Closure templates. For the client side, Soy templates are precompiled into efficient JavaScript.Soy templates use an easy templating language that also lets you use MetalJS components. With all these benefits and more, Soy can be a good front-end tool to have in your utility belt. Quick Guide Create a Soy File All files that contain Closure Templates end with the .soy file extension and are called Soy files. Write your template Each Soy file needs a namespace declaration at the top of the file. It must be declared before any templates are declared: {namespace examples.simple} For templates that need parameters, these must be declared in JavaDoc style immediately before the template: /* Renders a table of selected AJS.params @param userName */ Parameters use this syntax within the template: {$userName} Here a example of a template that says Hello to a specific user: {namespace simples.example} /* /Renders a Hello message. /@param userName */ {template .helloWorld} Hello {$userName}! {/template} Call the Soy template in a separate JavaScript file You can now invoke the template by simply calling a javascript function with your previously declared namespace. In this example it would be something like: //display a hello message on the page var template = simples.example.helloWorld({userName: \"John Smith\"}); AJS.messages.info(jQuery(\"body\"), {body: template, closeable: true}); More details, access closure.templates. ","srcFilePath":"src/pages/documentation/soy-templates/index.md","id":"soy-templates","location":"/documentation/soy-templates/","url":"/documentation/soy-templates/"},"service-builder":{"title":"Service Builder","description":"An application without reliable business logic or persistence isn’t much of an application at all. Unfortunately, writing your own persistence code often takes a great deal of time. Fortunately, Liferay provides the Liferay Service Builder to generate it for you. But, you can still write your own persistence code if you wish. And if you choose to use Service Builder, you can edit and customize the code it generates. Regardless of how you produce your persistence code, you can then use it to implement your app’s business logic.","layout":"guide","icon":"code-file","weight":5,"content":" {$page.description} What is Service Builder? Liferay Service Builder is a tool which is generally used to generate code to interact with database. Liferay Service Builder auto generate service layer code to interact with underlying database. The service builder tool takes xml file (its called service.xml) as an input and generate code based on the input provided in service.xml. This section explains the basics of liferay service builder. Service Builder is a model-driven code generation tool built by Liferay that allows developers to define custom object models called entities. Service Builder generates a service layer through object-relational mapping (ORM) technology that provides a clean separation between your object model and code for the underlying database. Besides that, Service Builder takes an XML file as input and generates the necessary model, persistence and service layers for your application. These layers provide a clean separation of concerns. Service Builder generates most of the common operations on the database, such as: create, read, update, find. Some of the main benefits of using Service Builder are: Integration with Liferay Automatically generated model, persistence, and service layers Automatically generated local and remote services Automatically generated Hibernate and Spring configurations Support for generating finder methods for entities and finder methods that account for permissions Built-in entity caching support Support for custom SQL queries and dynamic queries Saved development time Liferay uses Service Builder to generate all of its internal database persistence code. In fact, all of Liferay’s services, both local and remote, are generated by Service Builder. Additionally, the service modules in Liferay are generated by Service Builder. Service Builder’s use in Liferay Portal demonstrates it to be a robust and reliable tool. One of the main ways Service Builder saves development time is by completely eliminating the need to write and maintain database access code. To generate a basic service layer, you only need to create a service.xml file and run Service Builder. This generates a new service .jar file for your project. The generated service .jar file includes a model layer, a persistence layer, a service layer and related infrastructure. These distinct layers represent a healthy separation of concerns: Model Layer: define objects to represent the project’s entities. Persistence Layer: save and retrieve entities from the database. Service Layer: expose CRUD and related methods for the entities as an API. Each entity generated by Service Builder contains a model implementation class. Each entity also contains a local service implementation class, a remote service implementation class, or both, depending on how you configure Service Builder in your service.xml file. Customizations and business logic can be implemented in these three classes; in fact, these are the only classes generated by Service Builder that are intended to be customized. Ensuring that all customizations take place in only a few classes makes Service Builder projects easy to maintain. The local service implementation class is responsible for calling the persistence layer to retrieve and store data entities. Local services contain the business logic and access the persistence layer. They can be invoked by client code running in the same Java Virtual Machine. Remote services usually have additional code for permission checking and are meant to be accessible from anywhere over the Internet or your local network. Service Builder automatically generates the code necessary to allow access to the remote services. The remote services generated by Service Builder include SOAP utilities and can be accessed via SOAP or JSON. Another way Service Builder saves development time is by providing Spring and Hibernate configurations for the project. Service Builder uses Spring dependency injection for making service implementation classes available at runtime and uses Spring AOP for database transaction management. Service Builder also uses the Hibernate persistence framework for object-relational mapping. As a convenience to developers, Service Builder hides the complexities of using these technologies. Developers can take advantage of Dependency Injection (DI), Aspect Oriented Programming (AOP), and Object-Relational Mapping (ORM) in their projects without having to manually set up a Spring or Hibernate environment or make any configurations. Another benefit of using Service Builder is that it provides support for generating finder methods. Finder methods retrieve entity objects from the database based on specified parameters. It is only necessary to specify the kinds of finder methods to be generated in the service.xml configuration file and Service Builder does the rest. Beyond that, Service Builder also provides built-in caching support. Liferay caches objects at three levels: entity, finder, and Hibernate. By default, Liferay uses Ehcache as an underlying cache provider for each of these cache levels. However, this is configurable via portal properties. Service Builder is a flexible tool. It automates many of the common tasks associated with creating database persistence code but it doesn’t prevent you from creating custom SQL queries or custom finder methods. Service Builder allows developers to define custom SQL queries in an XML file and to implement custom finder methods to run the queries. This could be useful, for example, for retrieving specific pieces of information from multiple tables via an SQL join. Service Builder also supports retrieving database information via dynamic query. Liferay’s dynamic query API leverages Hibernate’s criteria API. In summary, Service Builder generates distinct model, persistence and service layers, local and remote services, Spring and Hibernate configurations, and related infrastructure without requiring any manual intervention by developers. It also allows basic SQL queries and finder methods to be generated and ones that filter results, taking Liferay’s permissions into account. Service Builder also provides support for entity and query caching. Finally, Service Builder is not a restrictive tool: it allows custom SQL queries and finder methods to be added and it also supports dynamic query. More details, access dev.liferay. ","srcFilePath":"src/pages/documentation/service-builder/index.md","id":"service-builder","location":"/documentation/service-builder/","url":"/documentation/service-builder/"}},"childIds":["introduction-liferay","osgi","portlet","mvc-portlet","service-builder","frontend-taglib","soy-templates","search"]},"team":{"title":"Team","description":"Everything you need to know to get started.","content":" Backend Team Stay informed about what is happening in the team. Choose a Topic Each one provides a description of how it is our daily work. ","srcFilePath":"src/pages/team/index.soy","id":"team","location":"/team/","url":"/team/","children":{"search":{"title":"Search team","description":"Find what you're looking for in the documentation.","hidden":true,"content":" Electric Docs Start learning how to leverage the power of . ","srcFilePath":"src/pages/team/search.soy","id":"search","location":"/team/search.html","url":"/team/search.html"},"collaboration":{"title":"Collaboration","description":"Teamwork is the ability to work together for a common vision. The ability to direct individual achievements focused on organizational goals.","layout":"team","icon":"people","weight":4,"content":" {$page.description} Keep in mind: All members should help each other where necessary, a request for help from any other should be considered a high priority. When replying to an email or other form of communication, be it digital or not, always be friendly and respectful. Absences must be communicated in advance through the channel chosen by the team. We should always be open to listening and providing constructive criticism. We always try to give feedback to the responsible person when we find something that needs to be improved. ","srcFilePath":"src/pages/team/collaboration/index.md","id":"collaboration","location":"/team/collaboration/","url":"/team/collaboration/"},"communication":{"title":"Communication","description":"","layout":"team","icon":"bullhorn","weight":6,"content":" {$page.description} Channels and Tools Email Slack: used globally by engineering for daily conversation (workspace: liferayeng.slack.com). Zoom: for team calls. Loop: for team announcements. Jira: for creating issues and keep track of the product progress. Github: for versioning control and source code management. Invision: to represent visually the interface behavior through the deliverables: workflow, breakpoints, motion and interface components. Zeppelin: for checking design specifications to create CSS and HTML. ","srcFilePath":"src/pages/team/communication/index.md","id":"communication","location":"/team/communication/","url":"/team/communication/"},"liferay":{"title":"Liferay","description":"","layout":"team","icon":"liferay-logo-2-tiny","weight":2,"content":" {$page.description} About Liferay Liferay makes software that helps companies create digital experiences on web, mobile and connected devices. The platform is open source, which makes it more reliable, innovative and secure. Besides that, the company try to leave a positive mark on the world through business and technology. Mission: Building a vibrant business that makes technology useful and invests in communities. Vision: See people realize their full potential to serve others. Values: Produce by Excellence Lead by Serving Value People Grow and Get Better Stay Nerd Here you can have access to introductory videos about the Liferay culture and teams. It is recommended that you start with the list below: What's Liferay Liferay's Vision Value Proposition Introduction to Engineering ","srcFilePath":"src/pages/team/liferay/index.md","id":"liferay","location":"/team/liferay/","url":"/team/liferay/"},"projects":{"title":"Projects","description":"This section describes the projects being developed involving the backend team at the Liferay Recife office.","layout":"team","icon":"groups","weight":3,"content":" {$page.description} Forms A form is responsible for collecting and storing customer data, and can become a very important tool for systematizing information for various purposes. Through them, it is possible to research, document, formalize communications and control activities of organizations. It is a fundamental tool because allows administrators focus on what really matters. The forms team is in charge of developing and maintaining all parts of the portal related with Forms: Forms, Dynamic Data Lists and Web Form. Also the Dynamic Data Mapping (DDM) framework which also powers Web Content Structures and Document Types. Workflow Workflow is a vital element to any business because it models how companies operates. Besides that, it is a central piece to apps communication. The team is in charge of developing and maintaining all parts of the portal related with Workflow: Kaleo Designer, Kaleo Engine, Workflow framework and Calendar. Analytics Liferay Experience Cloud is a SaaS offering to enhance digital marketing activities through insights into the activities of a company’s customers across all touchpoints in the enterprise, whether or not those touchpoints are on the Liferay platform. Experience Cloud will enable you to gather analytics on three different dimensions: about people, their interactions and their customer journeys. Meanwhile, the Liferay Recife team is developing the analytics about the interactions of the individuals with content, both in the touchpoint (e.g., scroll depth on a landing page) and asset level (e.g., form field leading to abandonment), that leads to insights into which touchpoints or assets are the best performing. ","srcFilePath":"src/pages/team/projects/index.md","id":"projects","location":"/team/projects/","url":"/team/projects/"},"routine":{"title":"Routine","description":"The backend team routine consists of daily work combined with strategic management to achieve the expected results. This strategic management is based in effective meetings, balanced workload and collaborative team spirit. This section will describe the ticket management and all meetings.","layout":"team","icon":"calendar","weight":5,"content":" {$page.description} Ticket Management All the work in progress in engineering is monitored by a issue management (Jira). This system provides bug tracking, issue tracking, and project management functions. In other words, helps the team to keep an eye on all the activities day by day. Every team has its own kanban board with all your integrants as participants. In that way, Everyone knows which activity is aimed at who and their progress throughout the sprint. The image below shows a kanban board, which it can be noticed the participants and their issues. This image below shows one created ticket: There are 5 types of work: Story: Small unit of work to deliver a particular value back to the customer. Bug: An error in a system that causes it to produce an incorrect or unexpected result. Regression bug: Regression is when something that used to work fine does not work properly anymore. Task: Reflect work or initiatives that are very technical. Pull Request: Reviews from different teams and components. Every work has a different workflow from the creation of the ticket until the delivery of the expected result. This example below shows the step by step and the workflow to a new user story: Open: Product Manager or Technical Leader create the user story. Backlog: Product Designer development. Ready for development: List of stories ready to be developed. Selected for development: List of stories committed to be developed in the next 2 weeks. In Development: Engineers start working on the story. In Review: Once development is completed, peer review, QA review and validation and, Brian’s review. Documentation: Does the story need documentation? Generate a draft! Design Review: Product Designer make sure that the story requirements were developed according to the guidelines provided. PM Review: Product Manager validates the use cases. 10. Closed. Bugs are the type of work that needs to be under control, it means that should not exceed a certain limited number. To guide the team which bug they should resolve first, there is a classification based on the portal risk matrix that classifies the bug on a scale of 1-5. The developers should resolved the bugs in the descending order of their fix priority. This image below shows the successful ticket management to the bugs and regressions bugs workflow: Meetings The team meetings have the objective to verify the status of the work, but also to check if there is any need or trouble. For a meeting to be productive, it is necessary to list the different motives to be discussed and to mark different sessions to discuss each topic separately. In this way, the meeting does not become exhaustive or confusing. There are different types of meetings: Backlog Refinement: An event to refine and update the backlog with initial effort for each ticket and an opportunity to alignment and re-evaluate tickets and priorities. This meeting will occur every two weeks, in the week before the Planning meeting. It must involve the product manager, technical leader, product designer. every two weeks, in the week before planning meeting. Planning: Understand the stories with the proper acceptance criteria. The Product Manager will present all the stories for the new cycle and the team will assess each story, commit/accepted it to the sprint and breakdown it into small subtasks. every Monday, check the calendar to see the schedule. Stand Up: An event for the development team to synchronize activities. daily at 2pm. Product Sync-up: An event to share and evolve the product collaboratively. Whenever there is a need. Retrospective: An opportunity for the team to inspect itself and create a plan for improvements to be done during the next iteration. Every two weeks. Guild Reunion: An event to talk about general topics of the backend as a team or to discuss about a new technology. It is a open space to share any interesting points of view and to suggest any kind of improvements. Every tuesday at 10am. ","srcFilePath":"src/pages/team/routine/index.md","id":"routine","location":"/team/routine/","url":"/team/routine/"}},"childIds":["liferay","projects","collaboration","routine","communication","search"]},"tutorials":{"title":"Tutorials","description":"Foo bar.","//url":"/tutorials/example/first-step.html/","//layout":false,"content":" Tutorials and Tips Little help when you need! Choose a Tutorial Each one provide step by step coverage for every core feature. ","srcFilePath":"src/pages/tutorials/index.soy","id":"tutorials","location":"/tutorials/","url":"/tutorials/","children":{"search":{"title":"Search","description":"Find what you're looking for in the documentation.","hidden":true,"content":" Electric Docs Start learning how Liferay does all that! ","srcFilePath":"src/pages/tutorials/search.soy","id":"search","location":"/tutorials/search.html","url":"/tutorials/search.html"},"bestPractice":{"title":"Best Programmings Practice","description":"This section shows some tips and good programming practices, showing how to organize the code and also the meaning of a clean code.","layout":"tips","icon":"","weight":4,"content":" {$page.description} Clean Code Simple: easy to understand code. Straight: go straight to the point, do not \"loop\" to achieve your goal. Efficient: code that does what is proposed. No duplicity: it does not do what another part of the code already does. Elegant: because it is different from other codes. Done with care: those who did had concern in producing that code. Programming Practices Add new methods in alphabetical order relative to the existing code. [JS] Do not deploy with any running breakpoints. Check the need to create unit tests before performing the pull request. Perform unit and integration tests before performing the pull request. Each line of code can not exceed 80 characters. Do not perform method chaining: person.setName(\"Peter\").setAge(21).introduce(); Verify that the branch is updated before committing. Make sure to write JavaDocs when it needed. Pay attention to finished your task before start new ones. ","srcFilePath":"src/pages/tutorials/bestPractice/index.md","id":"bestPractice","location":"/tutorials/bestPractice/","url":"/tutorials/bestPractice/"},"example":{"children":{"1step":{"title":"Step 1","description":"Foo bar.","buttonTitle":"I did step 1","parentId":"example","layout":"tutorial","time":90,"weight":1,"content":" {$page.title} Must have software for MacOS Users: Brew In the terminal: '/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)' More info: brew.sh ","srcFilePath":"src/pages/tutorials/example/1step.md","id":"1step","location":"/tutorials/example/1step.html","url":"/tutorials/example/1step.html"},"2step":{"title":"Step 2","description":"Foo bar.","buttonTitle":"I did step 2","parentId":"example","layout":"tutorial","time":90,"weight":2,"content":" {$page.title} Java JDK8 In the terminal: '$ curl -s \"https://get.sdkman.io\" | bash' Follow the instructions on-screen to complete installation. Next, open a new terminal or enter: '$ source \"$HOME/.sdkman/bin/sdkman-init.sh\"' Lastly, run the following code snippet to ensure that installation succeeded: '$ sdk version' If all went well, the version should be displayed. More info: sdkman.io ","srcFilePath":"src/pages/tutorials/example/2step.md","id":"2step","location":"/tutorials/example/2step.html","url":"/tutorials/example/2step.html"},"3step":{"title":"Step 3","description":"Foo bar.","buttonTitle":"I did step 3","parentId":"example","layout":"tutorial","time":90,"weight":3,"content":" MySQL and MySQL Workbench MySQL In the terminal: '$ brew install mysql' More info: SQL MySQL Workbench In the terminal: 'brew tap caskroom/cask' 'brew install brew-cask' 'brew cask install mysqlworkbench' `","srcFilePath":"src/pages/tutorials/example/3step.md","id":"3step","location":"/tutorials/example/3step.html","url":"/tutorials/example/3step.html"},"4step":{"title":"Step 4","description":"Foo bar.","buttonTitle":"I did step 4","parentId":"example","layout":"tutorial","time":90,"weight":4,"content":" SourceTree If you want to install SourceTree, you should access sourceTree and follow the instructions. ","srcFilePath":"src/pages/tutorials/example/4step.md","id":"4step","location":"/tutorials/example/4step.html","url":"/tutorials/example/4step.html"},"5step":{"title":"Step 5","description":"Foo bar.","buttonTitle":"I did step 5","parentId":"example","layout":"tutorial","time":90,"weight":5,"content":" Not mandatory, but they’re really interesting: Iterm2 zsh Oh my zsh If you wish install any of this, here is a link to help you out. ","srcFilePath":"src/pages/tutorials/example/5step.md","id":"5step","location":"/tutorials/example/5step.html","url":"/tutorials/example/5step.html"},"6step":{"title":"Step 6","description":"Foo bar.","buttonTitle":"I did step 6","parentId":"example","layout":"tutorial","time":90,"weight":6,"content":" Java IDE: Eclipse. Intellij. ","srcFilePath":"src/pages/tutorials/example/6step.md","id":"6step","location":"/tutorials/example/6step.html","url":"/tutorials/example/6step.html"},"7step":{"title":"Step 7","description":"Foo bar.","buttonTitle":"I did step 7","parentId":"example","layout":"tutorial","time":90,"weight":7,"content":" Text Editor: Sublime. Visual Studio Code.","srcFilePath":"src/pages/tutorials/example/7step.md","id":"7step","location":"/tutorials/example/7step.html","url":"/tutorials/example/7step.html"}},"title":"Software Installation","description":"Foo bar.","tutorialTitle":"Must have software for MacOS Users:","url":"/tutorials/example/1step.html","layout":false,"content":" ","srcFilePath":"src/pages/tutorials/example/index.soy","id":"example","location":"/tutorials/example/","customURL":true,"childIds":["1step","2step","3step","4step","5step","6step","7step"]},"tips":{"children":{"code":{"title":"Code","description":"","layout":"tips","icon":"","weight":1,"content":" {$page.description} New Code? On the terminal, access the modified code folder and run the command: 'gw clean deploy' Do you want to organize your code before Pull Request? In the terminal, run the following commands: Check for inconsistencies.: 'gw formatSource' Check for inconsistencies in the .jsp file: 'check_sf */.jsp' check for inconsistencies in the .soy file: 'mcritic XXX.soy' To run the command 'mcritic XXX.soy' command, you must perform the following: In the terminal: 'npm install -g metal-soy-critic' Any questions, access metal-soy-critic. To run the command 'check_sf */.jsp', you must perform the following: In the terminal: 'sudo npm install -g check-source-formatting' Any questions, access github.com/natecavanaugh. Do you want to run tests? In the terminal, access the test file of the folder containing the modified code. Unit tests: 'gw test' Integration Tests: 'gw testIntegration' Something's Wrong ? In the terminal, run the command: 'telnet localhost 11311' Check to see if the test file has been installed and uninstalled. 'uninstall NUMBERFILE' Observe the test file number and replace in 'XXX' To quit telnet: control + ']' . Repeat the tests! Run the command 'Ant all' Drop the server. Access the life-portal. Git clean -fdx. Git pull upstream master. Git push origin master. Run the command: 'Ant all'. ","srcFilePath":"src/pages/tutorials/tips/code.md","id":"code","location":"/tutorials/tips/code.html","url":"/tutorials/tips/code.html"},"eclipse":{"title":"Eclipse","description":"This section shows some tips related with the Eclipse IDE.","layout":"tips","icon":"","weight":3,"content":" {$page.description} Eclipse crashing? Access ' Eclipse - Content - Eclipse - eclipse.ini '. Edit the file on the line that contains 'Xms' and ' Xmx' with the amount of space. E.g.: Xms4G. Problems getting access to debug mode in eclipse? Check your setenv.sh file located in the bin folder of the tomcat. Make sure the contents of the file match the text below: CATALINAOPTS=\"$CATALINAOPTS -Dfile.encoding=UTF8 -Djava.net.preferIPv4Stack=true -Dorg.apache.catalina.loader.WebappClassLoader.ENABLECLEARREFERENCES=false -Duser.timezone=GMT -Xdebug -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n\" JMX_OPTS=\"-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.port=8099 -Dcom.sun.management.jmxremote.ssl=false\" CATALINAOPTS=\"${CATALINAOPTS} ${JMX_OPTS}\" if [ \"$1\" = \"jacoco\" ] then JACOCOOPTS=\"-javaagent:/YOURPATH/bundles/liferay-portal/tomcat-8.0.32/bin/jacocoagent.jar=destfile=/YOUR_PATH/liferay-portal/jacoco/liferay-jacoco.exec,excludes=,includes=*,output=file,append=true\" CATALINAOPTS=\"${CATALINAOPTS} ${JACOCO_OPTS}\" shift fi CATALINAOPTS=\"${CATALINAOPTS} -javaagent:/YOUR_PATH/liferay-portal/lib/portal/aspectj-weaver.jar -Dorg.aspectj.weaver.loadtime.configuration=com/liferay/aspectj/aop.xml\" JPDA_ADDRESS=\"8000\" Indentation Help ? Download plugin Arbitrary Lines . Help - Eclipse Marketplace Access the advanced settings. Eclipse - Preferences - General - Editors - Text Editors - Arbitrary Lines - Show Advanced Configuration Enable checkbox 'character size override' . Edit 'Override character width' field for 6.65. ","srcFilePath":"src/pages/tutorials/tips/eclipse.md","id":"eclipse","location":"/tutorials/tips/eclipse.html","url":"/tutorials/tips/eclipse.html"},"general":{"title":"General","description":"This section shows some tips related with computer configuration and some general orientation.","layout":"tips","icon":"","weight":4,"content":" {$page.description} Do you want to create an ALIAS? Access the terminal and type 'sublime .zshrc'. Add the desired ALIAS in the file. E.g.: alias gw=/Users/UserName/YOUR_PATH/liferay-portal/gradlew. Do you want to to kill the TomCat process? In the terminal: 'ps aux | grep tomcat' Then, run this command to kill the process. 'kill -9 XXX' Note the number returned after step 1 and enter in place of 'XXX'. Update the Macos Sierra? In the terminal: 'brew update'. Then, 'Brew install telnet'. Syncing pull requests with Jira: In the terminal: 'sudo npm install gh -g'. Then, 'sudo npm install gh-jira -g'. ","srcFilePath":"src/pages/tutorials/tips/general.md","id":"general","location":"/tutorials/tips/general.html","url":"/tutorials/tips/general.html"},"source-tree":{"title":"Source Tree","description":"This section shows some tips related with Source Tree.","layout":"tips","icon":"","weight":2,"content":" {$page.description} New Bug? Access the SourceTree. Update main branch (pull). Create a local branch only to work on the bug fixes. Remotes - Upstream - Master - Checkout Nomeie a nova branch pelo código do bug. E.g.: LPS - 1234. Do you want to commit? Check for inconsistencies in the changed code. Run testes. Save the work. Save as Stache. Update master branch (pull). Commit Your changed code will be in 'File status' Perform push (enable 'force push'). If the checkbox is not showing, enable it via: SourceTree - Preferences - Advanced - Allow force push. Run the pull request through the terminal. 'gh pr -s liferay' Confusion after committing? Did you commit any separate commit that should have gone next to another or missed the message of a commit? You can solve the problem by: Interactive Rebase Identify the commit that generated the problem. Select the commit just below it and choose the 'Rebase children of XXX interactively' option. Pop-up will open and a list of commits will be displayed. Identify the one you want. To edit the message of a commit, select it and click 'Edit message'. To join two separate commits, drag the desired commit one position above the other desired one and click 'Squash with previous'. Reset Master Identify the commit that generated the problem. Select the commit just below it and choose the option 'Reset master to this branch'. Any modifications made by you before this commit will return to the file status. Reorganize your commits. ","srcFilePath":"src/pages/tutorials/tips/source-tree.md","id":"source-tree","location":"/tutorials/tips/source-tree.html","url":"/tutorials/tips/source-tree.html"}},"title":"Tips","description":"","layout":"tips","icon":"","weight":5,"content":" {$page.description} ","srcFilePath":"src/pages/tutorials/tips/index.md","id":"tips","location":"/tutorials/tips/","url":"/tutorials/tips/","childIds":["code","source-tree","eclipse","general"]}},"childIds":["bestPractice","tips","search","example"]}},"childIds":["documentation","team","tutorials"]}}